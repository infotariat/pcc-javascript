{
  "name": "Pcc-javascript",
  "tagline": "My JavaScript course materials",
  "body": "# CIS 133W JavaScript, Week 4\r\n*There really is not much to this weeks lesson. If you have ever programmed before (in any language), you'll already be familiar with the \"If...Then\" statement. Granted, javascript uses it's own \"C Style\" syntax, but none the less, it is still pretty straight forward.*\r\n\r\n### Conditional statements\r\nThe typical javascript if-then statement looks like this:\r\n```javascript\r\nif (someCondition == true) {\r\n    // Execute a code block between the curly braces\r\n    // This could be one to thousands of lines of code\r\n} else if (someOtherCondition == true) {\r\n    // Execute some other block\r\n} else {\r\n    // Execute yet another thing.\r\n    // This will likely be a default, or \"success\" option of some kind, at\r\n    // least in a validation context.\r\n}\r\n```\r\nThe condition expression can be very simple or very complex, so long as it\r\nresolves to a true or false value. You can have as many **\"else if\"** statements as you want. That means you can potentially check for dozens or even hundreds of possible conditions.\r\n\r\nHere's an example:\r\n```javascript\r\nvar annualEarnings = document.getElementById(\"txtNetEarnings\");\r\n\r\nif (parseFloat(annualEarnings) >= 250000) {\r\n    taxRate = 0.50;\r\n} else if (parseFloat(annualEarnings) >= 100000) {\r\n    taxRate = 0.35;\r\n} else {\r\n    taxRate = 0.05;\r\n}\r\n```\r\n\r\n### Case sensitivity\r\nOne thing needs to be made totally clear is that when performing logical comparisons you need to be aware of case sensitivity issues. The letter **\"A\"** does not equal the letter **\"a\"** (at least not as far as the computer is concerned).\r\n\r\nIf you wish to compare textual (string) data and have it be Case Insensitive, then you simply convert each item compared to a like case (Both to upper Case for Example).\r\n\r\nYou can do this using the string object's \"toUpperCase()\" method or the string object's \"toLowerCase()\" method.\r\n\r\nLet's look at an example. First we see straight-up comparison:\r\n```javascript\r\nvar x = \"A\";\r\nvar y = \"a\";\r\nvar z;\r\n\r\nz = (x = y); // will result in z being FALSE\r\n```\r\nAnd then using the string method:\r\n```javascript\r\nvar x = \"A\";\r\nvar y = \"a\";\r\nvar z;\r\n\r\nz = (x.toUpperCase() = y.toUpperCase()); // will result in z being TRUE\r\n```\r\n\r\n### Data types and casting\r\nJust as case sensitivity may cause issues in your logical comparisons so to can data type issues. For example, the number \"1\" is NOT the same as the number \"1.000\" (At least not as far as your computer is concerned). Because of this, it is typically wise to convert or \"Cast\" numeric data to like datatypes prior to or during comparison operations.\r\n\r\nAn example, with straight comparison:\r\n```javascript\r\nvar x = \"1\";\r\nvar y = \"1.000\";\r\nvar z;\r\n\r\nz = (x = y); // MAY result in z being FALSE (depending on browsers, circumstances, etc)\r\n```\r\n\r\nNow with type casting, thanks to the **parseInt()** function:\r\n\r\n```javascript\r\nvar x = \"1\";\r\nvar y = \"1.000\";\r\nvar z;\r\n\r\nz = (parseInt(x) = parseInt(y)); // results in z being TRUE\r\n```\r\n\r\nSimilarly, you may get bizarre results with mathematical operations if you dont carefully parse values to the correct data type.\r\n\r\nConsider this example:\r\n```javascript\r\nvar theAge = document.getElementById(\"txtAge\").value;\r\nvar yearsToRetirement = document.getElementById(\"txtYearsToRetire\").value;\r\n\r\nvar ageAtRetirement = theAge + yearsToRetirement;\r\n```\r\n\r\nIf above, the user entered age 40 and YearsToRetirement of 25, you would expect the answer to be 65. However, in this example, javascript doesn't realize that you are wanting these values handled numerically. Instead of doing numeric adding, it will do TEXTUAL Adding so the result would be:\r\n```javascript\r\n4025\r\n```\r\n\r\nNOT what we were looking for.\r\n\r\nTo fix the issue, we would have to more carefully cast our input values to integers when doing the math:\r\n```javascript\r\nvar ageAtRetirement = parseInt(theAge) + parseInt(yearsToRetirement);\r\n```\r\n\r\nYou can also parse numeric values to a floating point number if you want to honor decimal values. To do this, you use the **parseFloat()** function.\r\n\r\nAn example:\r\n```javascript\r\nvar salary = document.getElementById(\"txtSalary\");\r\nvar taxRate = document.getElementById(\"txtTaxRate\");\r\n\r\nvar taxOwed = parseFloat(salary) * parseFloat(taxRate);\r\n\r\ndocument.getElementById(\"txtTaxOwed\").value = taxOwed.toString();\r\n```\r\n\r\nAs has been demonstrated above, you can also cast numeric values to strings using the **toString()** method.\r\n\r\nFor example:\r\n```javascript\r\nvar x;\r\nx = 123.456;\r\nalert(x.toString());\r\n```\r\n\r\nRemember, that *technically*, the **alert()** function requires a string argument (not a number). Even though, we may not necessarily *have* to cast the variable **x** to a string to display it via a javascript alert(), it is a better practice to do so as in the above example.\r\n\r\n### Validating input\r\nIt is very important to get into the habit of validating ALL user input. There are really two significant risks if you don't:\r\n\r\n1. Legitimate Users will enter bizarre\\unexpected values and blow your browser based application sky high (over flow errors, divide by zero errors, special characters, etc etc etc).\r\n2. Hackers will enter malicious content into your form fields. (SQL Injection Attacks OR Javascript entered into Form fields and posted to your server. This can dump cookie values, header data, etc.)\r\n\r\nOne thing to check for in form post data is for any HTML tags...For example, if a user entered ANY \"&lt\" or \"&gt\" characters in a form field, I would consider rejecting the data because that looks like a potential HTML or Javascript Block.\r\n\r\nIf you expect the user to enter numeric data, you can use the \"Is Not A Number\" Function, **isNaN()** to determine if the data value is Not A Number (returns true or false).\r\n\r\nExample:\r\n```javascript\r\nif(isNaN(document.forms[0].elements[3].value)) {\r\n    alert(\"Years of Service Must Be Numeric\");\r\n}\r\n```\r\n\r\n### Browser sniffing\r\nOne of the most common needs for you as a web developer will be the requirement to determine what browser your users are using. Due to differences in browsers regarding their use of javascript, you may need to write logic to branch in different directions based on the browser type, version, and even Operating System.\r\n\r\n### The navigator object\r\nThe **navigator** object exists in javascript for this very purpose. This object contains various properties that you can read to determine what browser is in use. The properties of the **navigator** object that you will likely need at some point or another are:\r\n\r\n+ **userAgent**\r\n+ **appName**\r\n+ **appVersion**\r\n+ **javaEnabled**\r\n+ **platform**\r\n\r\nTo retrieve those values, we simply access the **navigator** object:\r\n```javascript\r\ndocument.write(\"appName: \" + navigator.appName;);\r\n```\r\n\r\nThe **appName** property will return a large string (Usually). For Netscape, the property will return \"Netscape\" for IE, the property will return \"Microsoft Internet Explorer\". So...we can test which browser using the following code:\r\n```javascript\r\nvar isNS = false;\r\nvar isIE = false;\r\nvar isUnknown = false;\r\n\r\nvar sAppName;\r\nsAppName = navigator.appName;\r\n\r\nif (sAppName.indexOf(\"Netscape\") != -1) {\r\n    isNS = true;\r\n} else if (sAppName.indexOf(\"Microsoft\") != -1) {\r\n    isIE = true;\r\n} else {\r\n    isUnknown = true;\r\n}\r\n```\r\n\r\n### Limitations of the appName property\r\nOne problem with the **appName** attribute is that it is very inconsistent from browser to browser. For example, for a large percentage of the browsers out there, the appName property simply returns \"Mozilla\".\r\n\r\nWhy is this? you may ask. Well...the reason is simple. Most browsers are derived from the Original Mozilla browser code base and therefore they really ARE Mozilla (to an extent). Because of this, the wide use of **appName** for anything meaningful is not really seen in the real world.\r\n\r\nThe appVersion property also returns a large string (Usually). However, the numeric version value is always the first piece of the text, so we can still easily test which browser version using the following code:\r\n```javascript\r\nvar is4 = false;\r\nvar is5orAbove = false;\r\nvar is3orBelow = false;\r\n\r\nvar iAppVersion;\r\n\r\niAppVersion = parseInt(navigator.appVersion);\r\n\r\nif (iAppVersion >= 5) {\r\n    is5orAbove = true;\r\n} else if (iAppVersion = 4) {\r\n    is4 = true;\r\n} else {\r\n    is3orBelow = true;\r\n}\r\n```\r\n\r\n### Limitations of the appVersion property\r\nHmmmm. Of course, we also see that **appVersion** has MAJOR limitations as well. For example, with IE browsers the **appVersion** always returns \"4\" (even for IE 6 and IE 7).\r\n\r\nThe reason for this is also simple....the **appVersion** basically answers the question *\"What Browser FAMILY are you?\"*\r\n\r\nBrowser family indicates what basic set of features does the browser support. IE4 was the first IE browser to support DHTML and Cascading Style Sheets (CSS). *SO....when IE reports that it is IE4. It's not REALLY reporting it's \"VERSION\", it's really reporting it's FAMILY for basic browser support.* Yes this is very misleading.\r\n\r\nAgain, like **appName**, the version number is not generally used in real world applications.\r\n\r\n### The userAgent\r\nThe most useful piece of browser info is the **userAgent**. Although the output of this Navigator attribute is often cryptic, if you look at the output, you will see that you can *always* glean the *correct* Browser name *and* Version from the text. The text returned by this property is *always* unique from browser to browser so all you have to do is learn the specific text formats for each browser in order to parse the strings and glean the accurate browser name and version.\r\n\r\n### String parsing\r\nIn order to glean the browser info from **userAgent** string, you will need to use the **indexOf()** javascript function to parse out name and version info.\r\n\r\n### Detecting cookie support\r\nCookies are little pieces of data that browser applications can store on the client (End user) machine. These little data items are managed by the browser, and are standard Internet Protocol.\r\n\r\nCookie Values are used to **persist data** from page to page or between browser sessions. For example, to remember you as a past visitor, and to remember what you bought or looked at the last time you visited our site (Amazon.com Recommendations for example).\r\n\r\nYou will likely need the ability to both read and write cookie values via javascript. To do this, you first need to determine if the browser supports cookies.\r\n\r\nWith Newer browsers (IE4+ and Netscape6+), you can determine this using the **navigator** object **cookieEnabled** property.\r\n\r\nExample:\r\n```javascript\r\nif (navigator.cookieEnabled) {\r\n    alert(\"Your Browser Supports Cookies\");\r\n}\r\n```\r\n\r\n### Sniffing cookie support via \"feature detection\"\r\nSo what happens if you need to detect if a browser supports cookies, but that browser does not provide the cookiesEnabled member? The answer is \"Feature Detection\".\r\n\r\nFeature detection is a general technique in which you TEST to see if a feature works by trying it. If it works, the feature is supported. If it doesn't work, then obviously, the feature is NOT supported.\r\n\r\nFor example, for older browsers that do not provide the **cookiesEnabled** attribute, what you have to do is fire code that writes a cookie value (\"TestCookie\") for example, then you immediately attempt to read the value of that cookie back. If the value you wrote is read back, then you know the browser supports cookies.\r\n\r\n### Reading and writing cookies\r\nWith javascript, you will definitely need, at times, to read and write cookie values. In order to read and write cookie values, you need to know the Name of the cookie.\r\n\r\n**To write cookies, you specify the cookie name, the expiration date, the value, and a few other optional parameters (Path, Domain, Secure).**\r\n\r\nIf you don't specify an expiration date, then the cookie is \"Non-Persistent\", which means that the cookie is only available as long as the browser is open. When the browser is closed, the cookie is NOT written to disk. IF the expiration date is specified, then the cookie is written to disk until the expiration date and the cookie value will \"Persist\" across browser sessions.\r\n\r\nAs an example, consider this code which creates a non-persistent cookie named \"UserID\",\r\nwith a value of \"Gjackson\":\r\n```javascript\r\ndocument.cookie = \"UserID=Gjackson\";\r\n```\r\n\r\nThis example creates a persistent cookie named \"HasBeenSpammed\", with a value of \"TRUE\", and an expiration date of 7 days from the current date:\r\n```javascript\r\nvar cookieExpirationDate = new Date();\r\ncookieExpirationDate.setDate(cookieExpirationDate.getDate() + 7);\r\ndocument.cookie = \"Test=CookieVIL;Expires=\" + cookieExpirationDate.toString() + \";\"\r\n```\r\n\r\nReading a cookie is a little more difficult. The only thing we can do via javascript, is use the **document.cookie** property. This property returns ALL Cookies for the given page/scope in a semi-colon delimited list. We then must parse the name value pairs out of the content to find our cookie's individual cookie value (Similarly to how we parsed CGI Parameters out of the Query String in earlier examples).\r\n\r\nA typical cookie string might look something like this (notice the \";\" between each cookie):\r\n```javascript\r\n// 'returnGuest=1;userID=gjackson;LoggedIn=True;HasBeenSpammed=true;sessionid=1AFC0034B1003FAA0E'\r\n```\r\n\r\nHere's an example that reads the value of a cookie named \"UserID\":\r\n```javascript\r\nvar cookieValue = \"\";\r\nvar myCookie = \"\";\r\nvar cookieName = \"UserID\";\r\n\r\nvar ind;\r\nvar ind2;\r\n\r\nmyCookie = document.cookie;\r\nind = myCookie.indexOf(cookieName);\r\n\r\nif (ind == -1) {\r\n    cookieValue = \"N/A\";\r\n} else {\r\n    // Find the first semicolon AFTER the beginning of this cookie.\r\n    // The semicolon indicates the start of the NEXT cookie.\r\n    ind2 = myCookie.indexOf(\";\", ind);\r\n    if (ind2 == -1) {\r\n        ind2 = myCookie.length;\r\n    }\r\n    cookieValue = unescape(myCookie.substring(ind + cookieName.length + 1, ind2));\r\n}\r\n\r\nalert(\"UserId=\" + cookieValue);\r\n```\r\n\r\nI don't fully expect you to understand the above code (string parsing is a bit of a pain). However, I do hope that you will use the above code and see if you can get it to work for you in reading and writing cookie values. This is a very important javascript technique, that is really bread and butter of client side scripting.\r\n\r\n### Working with dates\r\nIn javascript, we are given a **Date** object to work with date values in our script. The **Date** object provides a plethora of functionality for comparing two date values, parsing date values, adding to and subtracting from a date value, etc.\r\n\r\nTo create a new date object with the current date and time, you simply instantiate a new date object with no parameters fed to the constructor. To create any new object instance, you simply use the **new** statement.\r\n\r\nExample:\r\n```javascript\r\nvar myDate = new Date();\r\nalert(\"The current date is: \" + myDate.toString());\r\n```\r\n\r\nTo calculate a future date (or past date), you can simply add or subtract to\\from a existing date object.\r\n\r\nThis example calculates a date 15 days from now:\r\n```javascript\r\nvar cookieExpirationDate = new Date();\r\ncookieExpirationDate.setDate(cookieExpirationDate.getDate() + 15);\r\ndocument.cookie = \"MyCookie=Junk;expires=\" + cookieExpirationDate.toString();\r\nalert(\"Cookie will expire on \" + cookieExpirationDate.toString());\r\n```\r\n\r\n### Other Date Object methods\r\n\r\n| Method            | Description                                   |\r\n| ----------------- |:---------------------------------------------:|\r\n| **getMinutes()**  | Number of minutes value in the Date Object    |\r\n| **getHours()**    | Returns hours value of the Date Object        |\r\n| **getDay()**      | Returns day value of the Date Object          |\r\n| **getMonth()**    | Returns Month value of the Date Object        |\r\n| **getFullYear()** | Returns 4 Digit Year value of the Date Object |\r\n\r\n### Deleting a cookie\r\nIn order to delete a cookie, you simply write over the top of the existing cookie with a persistence date *older* than **Now()**.\r\n\r\nExample:\r\n```javascript\r\nvar cookieExpirationDate = new Date();\r\ncookieExpirationDate.setDate(cookieExpirationDate.getDate() - 7);\r\ndocument.cookie = \"Test=;Expires=\" + cookieExpirationDate.toString() + \";\";\r\n```\r\n\r\n### Specifying a cookie's domain and path\r\n##### Cookie Path\r\nCookies are, by default, available to all other files in the same directory the cookie was created in. To make a cookie available to *all files on the webserver* use the **path** statement, similar to:\r\n\r\n```javascript\r\ndocument.cookie = \"javahere=yes;path=/\";\r\n```\r\n\r\nTo make the cookie available to *the javascript directory and all its subdirectories only* use a statement like:\r\n```javascript\r\ndocument.cookie = \"javahere=yes; path=/javascript\";\r\n```\r\n\r\nCookies may have the same name with different values.\r\n\r\n##### Domain\r\nThe **domain** parameter is used to set the domain the cookie is accessible to. A path can be set for your own domain only and the domain path must include at least two periods (**.domain.com**). It must match your server's domain name. Therefore *cookies are not a security risk since only the server that sets them can use them.*\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}